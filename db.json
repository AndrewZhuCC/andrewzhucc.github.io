{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-Anisina/source/css/blog-style.css","path":"css/blog-style.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-Anisina/source/css/syntax.styl","path":"css/syntax.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-Anisina/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-Anisina/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-Anisina/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-Anisina/source/js/blog.js","path":"js/blog.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-Anisina/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-Anisina/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-Anisina/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-Anisina/source/js/flowchart.js","path":"js/flowchart.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-Anisina/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-Anisina/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-Anisina/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-Anisina/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-Anisina/source/js/raphael-min.js","path":"js/raphael-min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-Anisina/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-Anisina/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/README.md","hash":"feab09dfaa2212528428d850bb89db7b670113ba","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/_config.yml","hash":"1a6492e8ab3d6f3ab6a374d037dbff2b98a8eb22","modified":1476348241000},{"_id":"themes/hexo-theme-Anisina/package.json","hash":"12541fbf56f785e4f5d486a55b4939f3033f625b","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/.git/FETCH_HEAD","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1476361379000},{"_id":"source/404/index.md","hash":"6ea425daac0dc4521b998fb6f863e8c19379b188","modified":1476357561000},{"_id":"source/Tags/index.md","hash":"f0613a64c04fefd98961475a25f85338d03cf5d4","modified":1476352583000},{"_id":"source/_posts/.DS_Store","hash":"25af5748ff27e17e8220e324506922c512f4356f","modified":1476686356000},{"_id":"source/_posts/AZ-THPerformanceMonitor.md","hash":"3360b1fce313f791393a23de8e056b4f546a392b","modified":1476691288000},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1476352087000},{"_id":"source/_posts/iOS-RunLoop.md","hash":"44f4979950c5a71cc0fbfe10536edb63243ddd1a","modified":1476440800000},{"_id":"source/_posts/ltpost.md","hash":"1bea253af5b702b27d9300c1e7bc6a66378a3aa8","modified":1476692391000},{"_id":"source/flowchart/index.html","hash":"8e8009ce48df31333ca4e58c3954256741c66bdd","modified":1476432408000},{"_id":"source/about/index.md","hash":"3fbca574ceb52e155cdfe5518a4eb1eb8d62c7b3","modified":1476432603000},{"_id":"themes/hexo-theme-Anisina/.git/COMMIT_EDITMSG","hash":"287194ad33f64982d262d9bfa5d092c91672b8c3","modified":1476441036000},{"_id":"themes/hexo-theme-Anisina/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/.git/config","hash":"3604a35f0d71f992772596e2398ac38689353b11","modified":1476361403000},{"_id":"themes/hexo-theme-Anisina/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1476347478000},{"_id":"themes/hexo-theme-Anisina/.git/index","hash":"007a4d21dd0b0fe121d4be4c3dc3dfed2dfb8ee6","modified":1476441036000},{"_id":"themes/hexo-theme-Anisina/.git/packed-refs","hash":"6f299e362770d70250edb034cd187c9f3988f689","modified":1476361235000},{"_id":"themes/hexo-theme-Anisina/Screenshots/mobile-index.jpeg","hash":"cd75f77f5d865d42182e2233e354eeba9f114d98","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/layout/404.ejs","hash":"1fe05722bd1b32bbe0ae4e3e880866f935e0ae11","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/layout/archive.ejs","hash":"056fc63ffad55cf12595b6a0e55616cf7b754784","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/layout/layout.ejs","hash":"9d3d82a707b107f42db34ef5a8016693da2be742","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/layout/index.ejs","hash":"a94ac678f6b24a46824d45ec058b0ab2105a92c9","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/layout/page.ejs","hash":"2799e0105a5cce223a0a3e04aeece3bbe57fa7b5","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/layout/poetry.ejs","hash":"6c955d419050825e13d39c780d45aceafbf6552d","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/layout/post.ejs","hash":"07a81a2b5c3cdb0692935e4a876219e5a5c645bd","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/layout/tags.ejs","hash":"a144c3b5f4a70f881333e4de392a265469cdb649","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/layout/works.ejs","hash":"1df954e54098cc4845295836374abed870789dcd","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/source/.DS_Store","hash":"414aec04f6358bb3aa2ed928bfe4359c877568c9","modified":1476429467000},{"_id":"themes/hexo-theme-Anisina/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1476347478000},{"_id":"themes/hexo-theme-Anisina/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1476347478000},{"_id":"themes/hexo-theme-Anisina/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1476347478000},{"_id":"themes/hexo-theme-Anisina/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1476347478000},{"_id":"themes/hexo-theme-Anisina/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1476347478000},{"_id":"themes/hexo-theme-Anisina/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1476347478000},{"_id":"themes/hexo-theme-Anisina/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1476347478000},{"_id":"themes/hexo-theme-Anisina/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1476347478000},{"_id":"themes/hexo-theme-Anisina/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1476347478000},{"_id":"themes/hexo-theme-Anisina/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1476347478000},{"_id":"themes/hexo-theme-Anisina/.git/logs/HEAD","hash":"54c37d97635fe3fc590fde3a7fe160367633648d","modified":1476441036000},{"_id":"themes/hexo-theme-Anisina/Screenshots/Anisina.png","hash":"146dd991f55a827a514259e20a51de1e9b07a13d","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/layout/_partial/footer.ejs","hash":"223a29b0154c2dcc5f8a6b6fee67ef78ead266ad","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/layout/_partial/head.ejs","hash":"ec828fadf26726db74f7c96d096c17481ec4fe70","modified":1476440967000},{"_id":"themes/hexo-theme-Anisina/layout/_partial/nav.ejs","hash":"610b162407381d787a96c382918eb20689c8c195","modified":1476692285000},{"_id":"themes/hexo-theme-Anisina/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/source/css/blog-style.css","hash":"d064f7fd3b16dabca768a06e9779cbb7ba608ce7","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/source/css/syntax.styl","hash":"f3f9ff0d1ebc4f7fa18d7e367b2ba2f0899adbd4","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/source/js/blog.js","hash":"0f805c744ef8a48c0abdd9d204cfc19ee6cafc14","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/source/js/flowchart.js","hash":"ffc5a9f31670f2c8eaa7a2c6c31097ccea753473","modified":1476431255000},{"_id":"themes/hexo-theme-Anisina/source/js/totop.js","hash":"11ede60fccb7c763d6973f80efc78b47c0843746","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/Screenshots/poetry-show.png","hash":"f5fdcd25026a87a0aafeebb1f19cdb3c0a81a666","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/source/css/bootstrap.min.css","hash":"c5db932e115ff97af7b4512b947cde3ba2964db8","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/source/js/raphael-min.js","hash":"bfd83096d2178219ccd3f8fc592ae41cdf4e822e","modified":1476431224000},{"_id":"themes/hexo-theme-Anisina/.git/objects/0b/584c06b2d4e6b07f1dcf235ed6f5852fbbb298","hash":"76185cec8cb0d0c61bec36e5a2f6b1009440ef98","modified":1476361264000},{"_id":"themes/hexo-theme-Anisina/.git/objects/1c/76ef64d105a02e4f4675a8302d4a6b96f0b1eb","hash":"daed6c1d2acede62913d394162538b04d9c8dfed","modified":1476441036000},{"_id":"themes/hexo-theme-Anisina/.git/objects/28/876ce3da3f47e096c260a523c921ad5e236ffc","hash":"48fedc05b867dab9efa6bbe3ccfb696877e04a6e","modified":1476361960000},{"_id":"themes/hexo-theme-Anisina/.git/objects/31/227dfafea18cdb78774a117785d043cdc00c44","hash":"e9bdd4d526242f3ba7a39974e0e8c286bdbc78da","modified":1476361276000},{"_id":"themes/hexo-theme-Anisina/.git/objects/37/300268a952ede899d2025e62cd2c8f799559c9","hash":"a12a9c986aeb2f17cfc7a4686d9f32125fcbce68","modified":1476437341000},{"_id":"themes/hexo-theme-Anisina/.git/objects/34/f78a546d23da227129b688ddd5b6bcd774a4aa","hash":"17afe3af5a0dbbee5daf70a02231c07048babc85","modified":1476441036000},{"_id":"themes/hexo-theme-Anisina/.git/objects/37/d690d4fa0b22bbc2a76b5d438da967f443fdcb","hash":"d4d20a5b482db2a6c7fee236c7aa55f05c0d4edd","modified":1476361960000},{"_id":"themes/hexo-theme-Anisina/.git/objects/3b/d2c4b66c4063656815922ce8aeab8302ad4faa","hash":"e965287bd3e694b4c09f538f929e4e35eafbee4a","modified":1476375002000},{"_id":"themes/hexo-theme-Anisina/.git/objects/3f/02245ee07bc499bb2043ac136d6972de6ce698","hash":"678aa536edfed6cec341484946cd4f3ba0b7ad0a","modified":1476375002000},{"_id":"themes/hexo-theme-Anisina/.git/objects/66/f29deab5a75dcc31fad2544ac0096c1e487661","hash":"5b616e11995b4fe2f91f1f796861a473b8b77731","modified":1476441028000},{"_id":"themes/hexo-theme-Anisina/.git/objects/4b/b97aaee8f984c043bd54322d8c9108a20f6f1a","hash":"54479a7b22255691625c491f981415febf909bea","modified":1476437341000},{"_id":"themes/hexo-theme-Anisina/.git/objects/53/d828e912a933286d51b1b2a11fcbd8010347c6","hash":"3e67863198c5c5181639c4a857c1554d895ed2a9","modified":1476361960000},{"_id":"themes/hexo-theme-Anisina/.git/objects/6a/403e982cf4188d1622f0cafdf8ea3baf5677b3","hash":"3e36370b8bb5d6e292ec43ed69aaab42eaa1cef9","modified":1476441036000},{"_id":"themes/hexo-theme-Anisina/.git/objects/6b/3e247b50d3b3b12ae1a0faa50e04bbc18f6a45","hash":"a5433ad2bf98f279834a47abe636742cf168bedd","modified":1476437341000},{"_id":"themes/hexo-theme-Anisina/.git/objects/71/965412348de43eb5f96f7ef1e898fd89513ffc","hash":"4bcc4978f5b1e4c8c2681b37145ff29370997eac","modified":1476374993000},{"_id":"themes/hexo-theme-Anisina/.git/objects/75/7b838e933d5db0c67ca5ad7dacab05de80eb65","hash":"6579c9437405e1b2b76c22be0fe15bd221ca3a57","modified":1476441036000},{"_id":"themes/hexo-theme-Anisina/.git/objects/76/7cdb8db6378b57c95a1841f4068339c6288421","hash":"964763de5bfd222299621157d11967e43cfc2eb7","modified":1476375002000},{"_id":"themes/hexo-theme-Anisina/.git/objects/7b/80b6d65c38852e58b2dbf90b9669801db14385","hash":"156962789f2c3c884e7b4501da5a5c48b90f3c13","modified":1476361276000},{"_id":"themes/hexo-theme-Anisina/.git/objects/7c/54435cccf54884c4e7bb0014df7232f0bbb7ea","hash":"0ecc7f3d49c85ed02cd833d1837610d14e31261e","modified":1476375002000},{"_id":"themes/hexo-theme-Anisina/.git/objects/87/df3e033958a491146f7ea0b6110a4a5f4d8be7","hash":"d4363d8f1fff434719657f07589b4f490e0fac9d","modified":1476361276000},{"_id":"themes/hexo-theme-Anisina/.git/objects/98/797a2f743f1f7814c5fb544d6f35012bbc5f32","hash":"7ebe0bae589a316628d306283bb4684464c2fbf1","modified":1476437341000},{"_id":"themes/hexo-theme-Anisina/.git/objects/98/b8254a883fca1cd3f337e3c2af2dda9cd83006","hash":"9c79f137b236a281d26091a4361019c7a49e792a","modified":1476361276000},{"_id":"themes/hexo-theme-Anisina/.git/objects/b9/574fb515be432fe4020b3d8bef34389b4e8e0b","hash":"04e5b1bd7e1bb0c67be3907f615606c606ada167","modified":1476437341000},{"_id":"themes/hexo-theme-Anisina/.git/objects/c1/daf0e72b77e83f76ca64fe2dc26fe6c25793a3","hash":"e8be7dca3e275e52d228aadbd25ace35549dca01","modified":1476361960000},{"_id":"themes/hexo-theme-Anisina/.git/objects/cb/ee5aca25196b676ea4fc41c6160dcdac37bf4d","hash":"3c681980834a93639d2eb68116838aea707f1c47","modified":1476437319000},{"_id":"themes/hexo-theme-Anisina/.git/objects/d6/85a625d69d32ea727ba6b0f881d94aae8e9cd9","hash":"8698bb18d9fe18bc5ec7eb42fd4ecec65b332c0f","modified":1476361948000},{"_id":"themes/hexo-theme-Anisina/.git/objects/dd/16a392be8fe45831a67390f4e819ad4f162a5b","hash":"5d66c97102b0fc9616c79d1b2a69d77b28546613","modified":1476437341000},{"_id":"themes/hexo-theme-Anisina/.git/objects/ca/620cce2f5b2e31977b10b6376ac6355eb6df35","hash":"6c65534792a5da83db6f42642ecbcb8a1b794e4e","modified":1476437319000},{"_id":"themes/hexo-theme-Anisina/.git/objects/pack/pack-4419db553205cd76623376ba55766cd084ca9d45.idx","hash":"2fabbadbc904a59560ad057add5d82011cbda38d","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/.git/refs/heads/master","hash":"a280f00b83359878ee355b56f95d12f6c0c5a249","modified":1476441036000},{"_id":"themes/hexo-theme-Anisina/.git/objects/d3/0dbad858fcbf9b06edb7bff74cb8feecaa8b71","hash":"6c1764323fe11f328ac95683fe580c6041455303","modified":1476437319000},{"_id":"themes/hexo-theme-Anisina/Screenshots/mobile-post.jpeg","hash":"2081cdff23a9a8c185a48d9aabcc9dc8e77833ec","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/.git/logs/refs/heads/master","hash":"54c37d97635fe3fc590fde3a7fe160367633648d","modified":1476441036000},{"_id":"themes/hexo-theme-Anisina/.git/refs/remotes/origin/master","hash":"a280f00b83359878ee355b56f95d12f6c0c5a249","modified":1476441047000},{"_id":"themes/hexo-theme-Anisina/Screenshots/pc-index.png","hash":"b04094dac75cb656b4244c1dfaf246168a0f8926","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/.git/logs/refs/remotes/origin/HEAD","hash":"6c467434673260fc5145fa39bfecc2960423ea39","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/.git/logs/refs/remotes/origin/master","hash":"adec50aa7f0867268cb2546626fd875ff5e3990b","modified":1476441047000},{"_id":"themes/hexo-theme-Anisina/Screenshots/pc-post.png","hash":"cde56c0797b6ff8dd555fb1f8c3f9b21bceaa3be","modified":1476347666000},{"_id":"themes/hexo-theme-Anisina/.git/objects/pack/pack-4419db553205cd76623376ba55766cd084ca9d45.pack","hash":"7401ae72ede9a4bd4ebc6c0b1e1576b136797a17","modified":1476347666000},{"_id":"public/404/index.html","hash":"843498fac476f862d5552ef10a3b1492dbeae3ec","modified":1476693045888},{"_id":"public/Tags/index.html","hash":"1046fa2a7376c550b42e9df5619bebde5932af54","modified":1476693045888},{"_id":"public/about/index.html","hash":"61bbad4adb7065e7496da05d389d8494a7ac14d6","modified":1476693045889},{"_id":"public/archives/index.html","hash":"806764d1488a0b81a224ccea7ab430ff6ecfe22d","modified":1476693045889},{"_id":"public/archives/2016/10/index.html","hash":"60013d55af6f6c23b4478859c97f7a201df9985c","modified":1476693045889},{"_id":"public/archives/2016/index.html","hash":"3e16d30a7952cb336433976e7976030016392b69","modified":1476693045889},{"_id":"public/tags/iOS/index.html","hash":"ee4ffdad3bd5a3922b0328d39697a86210708dcf","modified":1476693045889},{"_id":"public/tags/Framework/index.html","hash":"cf13ec494554a2f6a4eae22707144c0efb2905cc","modified":1476693045889},{"_id":"public/tags/OpenSource/index.html","hash":"134858fc31b8c16fd2a3be8678106c5366cd4f49","modified":1476693045889},{"_id":"public/tags/Code/index.html","hash":"8e94ecd2eba1c98087162d788a3b2cac73adb2fb","modified":1476693045889},{"_id":"public/flowchart/index.html","hash":"e1e18070953a6a2eeaceaf81193b62796196b0a1","modified":1476693045889},{"_id":"public/2016/10/17/ltpost/index.html","hash":"cba5dd6ba867c006138667db3a10789ef0778229","modified":1476693045889},{"_id":"public/2016/10/14/iOS-RunLoop/index.html","hash":"754586c70f0fe63f9af449accf06bac98c906f23","modified":1476693045889},{"_id":"public/2016/10/17/AZ-THPerformanceMonitor/index.html","hash":"da7df1c7176534d8ea900a65273cce25caa62a90","modified":1476693045889},{"_id":"public/2016/10/13/hello-world/index.html","hash":"75090a7d3f803f6ce63cd3807678f92a1b032480","modified":1476693045889},{"_id":"public/index.html","hash":"5be60b522fd73c026b3b91b7eceb6777a663d653","modified":1476693045889},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1476693045892},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1476693045892},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1476693045893},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1476693045893},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1476693046140},{"_id":"public/css/syntax.css","hash":"4616879fec214c9cc4f5835615348f0bbeabf2a9","modified":1476693046147},{"_id":"public/js/blog.js","hash":"0f805c744ef8a48c0abdd9d204cfc19ee6cafc14","modified":1476693046147},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1476693046147},{"_id":"public/js/totop.js","hash":"11ede60fccb7c763d6973f80efc78b47c0843746","modified":1476693046147},{"_id":"public/css/blog-style.css","hash":"d064f7fd3b16dabca768a06e9779cbb7ba608ce7","modified":1476693046147},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1476693046147},{"_id":"public/js/flowchart.js","hash":"ffc5a9f31670f2c8eaa7a2c6c31097ccea753473","modified":1476693046147},{"_id":"public/js/raphael-min.js","hash":"bfd83096d2178219ccd3f8fc592ae41cdf4e822e","modified":1476693046147},{"_id":"public/css/bootstrap.min.css","hash":"c5db932e115ff97af7b4512b947cde3ba2964db8","modified":1476693046147},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1476693046147},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1476693046147}],"Category":[],"Data":[],"Page":[{"title":"404","date":"2016-10-13T11:19:00.000Z","layout":"404","_content":"","source":"404/index.md","raw":"---\ntitle: 404\ndate: 2016-10-13 19:19:00\nlayout: 404\n---\n","updated":"2016-10-13T11:19:21.000Z","path":"404/index.html","comments":1,"_id":"ciudswu6w0000de1ae3dznjc1","content":"","excerpt":"","more":""},{"title":"Tags","date":"2016-10-13T09:55:39.000Z","layout":"tags","_content":"","source":"Tags/index.md","raw":"---\ntitle: Tags\ndate: 2016-10-13 17:55:39\nlayout: tags\n---\n","updated":"2016-10-13T09:56:23.000Z","path":"Tags/index.html","comments":1,"_id":"ciudswu720002de1a5lm3zwsl","content":"","excerpt":"","more":""},{"_content":"<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <title>flowchart.js · Playground</title>\n        <style type=\"text/css\">\n          .end-element { background-color : #FFCCFF; }\n        </style>\n        <script src=\"http://cdnjs.cloudflare.com/ajax/libs/raphael/2.1.0/raphael-min.js\"></script>\n        <script src=\"http://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.0/jquery.min.js\"></script>\n        <script src=\"http://flowchart.js.org/flowchart-latest.js\"></script>\n        <!--<script src=\"../release/flowchart.min.js\"></script>-->\n        <script>\n            window.onload = function () {\n                var btn = document.getElementById(\"run\"),\n                    cd = document.getElementById(\"code\"),\n                    chart;\n                (btn.onclick = function () {\n                    var code = cd.value;\n                    if (chart) {\n                      chart.clean();\n                    }\n                    chart = flowchart.parse(code);\n                    chart.drawSVG('canvas', {\n                      // 'x': 30,\n                      // 'y': 50,\n                      'line-width': 3,\n                      'line-length': 50,\n                      'text-margin': 10,\n                      'font-size': 14,\n                      'font': 'normal',\n                      'font-family': 'Helvetica',\n                      'font-weight': 'normal',\n                      'font-color': 'black',\n                      'line-color': 'black',\n                      'element-color': 'black',\n                      'fill': 'white',\n                      'yes-text': 'yes',\n                      'no-text': 'no',\n                      'arrow-end': 'block',\n                      'scale': 1,\n                      'symbols': {\n                        'start': {\n                          'font-color': 'red',\n                          'element-color': 'green',\n                          'fill': 'yellow'\n                        },\n                        'end':{\n                          'class': 'end-element'\n                        }\n                      },\n                      'flowstate' : {\n                        'past' : { 'fill' : '#CCCCCC', 'font-size' : 12},\n                        'current' : {'fill' : 'yellow', 'font-color' : 'red', 'font-weight' : 'bold'},\n                        'future' : { 'fill' : '#FFFF99'},\n                        'request' : { 'fill' : 'blue'},\n                        'invalid': {'fill' : '#444444'},\n                        'approved' : { 'fill' : '#58C4A3', 'font-size' : 12, 'yes-text' : 'APPROVED', 'no-text' : 'n/a' },\n                        'rejected' : { 'fill' : '#C45879', 'font-size' : 12, 'yes-text' : 'n/a', 'no-text' : 'REJECTED' }\n                      }\n                    });\n                    $('[id^=sub1]').click(function(){\n                      alert('info here');\n                    });\n                })();\n            };\n        </script>\n    </head>\n    <body>\n        <div><textarea id=\"code\" style=\"width: 100%;\" rows=\"11\">\nst=>start: Start|past:>http://www.google.com[blank]\ne=>end: End:>http://www.google.com\nop1=>operation: My Operation|past\nop2=>operation: Stuff|current\nsub1=>subroutine: My Subroutine|invalid\ncond=>condition: Yes\nor No?|approved:>http://www.google.com\nc2=>condition: Good idea|rejected\nio=>inputoutput: catch something...|request\n\nst->op1(right)->cond\ncond(yes, right)->c2\ncond(no)->sub1(left)->op1\nc2(yes)->io->e\nc2(no)->op2->e\n        </textarea></div>\n        <div><button id=\"run\" type=\"button\">Run</button></div>\n        <div id=\"canvas\"></div>\n    </body>\n</html>\n","source":"flowchart/index.html","raw":"<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <title>flowchart.js · Playground</title>\n        <style type=\"text/css\">\n          .end-element { background-color : #FFCCFF; }\n        </style>\n        <script src=\"http://cdnjs.cloudflare.com/ajax/libs/raphael/2.1.0/raphael-min.js\"></script>\n        <script src=\"http://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.0/jquery.min.js\"></script>\n        <script src=\"http://flowchart.js.org/flowchart-latest.js\"></script>\n        <!--<script src=\"../release/flowchart.min.js\"></script>-->\n        <script>\n            window.onload = function () {\n                var btn = document.getElementById(\"run\"),\n                    cd = document.getElementById(\"code\"),\n                    chart;\n                (btn.onclick = function () {\n                    var code = cd.value;\n                    if (chart) {\n                      chart.clean();\n                    }\n                    chart = flowchart.parse(code);\n                    chart.drawSVG('canvas', {\n                      // 'x': 30,\n                      // 'y': 50,\n                      'line-width': 3,\n                      'line-length': 50,\n                      'text-margin': 10,\n                      'font-size': 14,\n                      'font': 'normal',\n                      'font-family': 'Helvetica',\n                      'font-weight': 'normal',\n                      'font-color': 'black',\n                      'line-color': 'black',\n                      'element-color': 'black',\n                      'fill': 'white',\n                      'yes-text': 'yes',\n                      'no-text': 'no',\n                      'arrow-end': 'block',\n                      'scale': 1,\n                      'symbols': {\n                        'start': {\n                          'font-color': 'red',\n                          'element-color': 'green',\n                          'fill': 'yellow'\n                        },\n                        'end':{\n                          'class': 'end-element'\n                        }\n                      },\n                      'flowstate' : {\n                        'past' : { 'fill' : '#CCCCCC', 'font-size' : 12},\n                        'current' : {'fill' : 'yellow', 'font-color' : 'red', 'font-weight' : 'bold'},\n                        'future' : { 'fill' : '#FFFF99'},\n                        'request' : { 'fill' : 'blue'},\n                        'invalid': {'fill' : '#444444'},\n                        'approved' : { 'fill' : '#58C4A3', 'font-size' : 12, 'yes-text' : 'APPROVED', 'no-text' : 'n/a' },\n                        'rejected' : { 'fill' : '#C45879', 'font-size' : 12, 'yes-text' : 'n/a', 'no-text' : 'REJECTED' }\n                      }\n                    });\n                    $('[id^=sub1]').click(function(){\n                      alert('info here');\n                    });\n                })();\n            };\n        </script>\n    </head>\n    <body>\n        <div><textarea id=\"code\" style=\"width: 100%;\" rows=\"11\">\nst=>start: Start|past:>http://www.google.com[blank]\ne=>end: End:>http://www.google.com\nop1=>operation: My Operation|past\nop2=>operation: Stuff|current\nsub1=>subroutine: My Subroutine|invalid\ncond=>condition: Yes\nor No?|approved:>http://www.google.com\nc2=>condition: Good idea|rejected\nio=>inputoutput: catch something...|request\n\nst->op1(right)->cond\ncond(yes, right)->c2\ncond(no)->sub1(left)->op1\nc2(yes)->io->e\nc2(no)->op2->e\n        </textarea></div>\n        <div><button id=\"run\" type=\"button\">Run</button></div>\n        <div id=\"canvas\"></div>\n    </body>\n</html>\n","date":"2016-10-14T08:06:48.000Z","updated":"2016-10-14T08:06:48.000Z","path":"flowchart/index.html","title":"","comments":1,"layout":"page","_id":"ciudswu88000hde1alta40bwr","content":"<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <title>flowchart.js · Playground</title>\n        <style type=\"text/css\">\n          .end-element { background-color : #FFCCFF; }\n        </style>\n        <script src=\"http://cdnjs.cloudflare.com/ajax/libs/raphael/2.1.0/raphael-min.js\"></script>\n        <script src=\"http://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.0/jquery.min.js\"></script>\n        <script src=\"http://flowchart.js.org/flowchart-latest.js\"></script>\n        <!--<script src=\"../release/flowchart.min.js\"></script>-->\n        <script>\n            window.onload = function () {\n                var btn = document.getElementById(\"run\"),\n                    cd = document.getElementById(\"code\"),\n                    chart;\n                (btn.onclick = function () {\n                    var code = cd.value;\n                    if (chart) {\n                      chart.clean();\n                    }\n                    chart = flowchart.parse(code);\n                    chart.drawSVG('canvas', {\n                      // 'x': 30,\n                      // 'y': 50,\n                      'line-width': 3,\n                      'line-length': 50,\n                      'text-margin': 10,\n                      'font-size': 14,\n                      'font': 'normal',\n                      'font-family': 'Helvetica',\n                      'font-weight': 'normal',\n                      'font-color': 'black',\n                      'line-color': 'black',\n                      'element-color': 'black',\n                      'fill': 'white',\n                      'yes-text': 'yes',\n                      'no-text': 'no',\n                      'arrow-end': 'block',\n                      'scale': 1,\n                      'symbols': {\n                        'start': {\n                          'font-color': 'red',\n                          'element-color': 'green',\n                          'fill': 'yellow'\n                        },\n                        'end':{\n                          'class': 'end-element'\n                        }\n                      },\n                      'flowstate' : {\n                        'past' : { 'fill' : '#CCCCCC', 'font-size' : 12},\n                        'current' : {'fill' : 'yellow', 'font-color' : 'red', 'font-weight' : 'bold'},\n                        'future' : { 'fill' : '#FFFF99'},\n                        'request' : { 'fill' : 'blue'},\n                        'invalid': {'fill' : '#444444'},\n                        'approved' : { 'fill' : '#58C4A3', 'font-size' : 12, 'yes-text' : 'APPROVED', 'no-text' : 'n/a' },\n                        'rejected' : { 'fill' : '#C45879', 'font-size' : 12, 'yes-text' : 'n/a', 'no-text' : 'REJECTED' }\n                      }\n                    });\n                    $('[id^=sub1]').click(function(){\n                      alert('info here');\n                    });\n                })();\n            };\n        </script>\n    </head>\n    <body>\n        <div><textarea id=\"code\" style=\"width: 100%;\" rows=\"11\">\nst=>start: Start|past:>http://www.google.com[blank]\ne=>end: End:>http://www.google.com\nop1=>operation: My Operation|past\nop2=>operation: Stuff|current\nsub1=>subroutine: My Subroutine|invalid\ncond=>condition: Yes\nor No?|approved:>http://www.google.com\nc2=>condition: Good idea|rejected\nio=>inputoutput: catch something...|request\n\nst->op1(right)->cond\ncond(yes, right)->c2\ncond(no)->sub1(left)->op1\nc2(yes)->io->e\nc2(no)->op2->e\n        </textarea></div>\n        <div><button id=\"run\" type=\"button\">Run</button></div>\n        <div id=\"canvas\"></div>\n    </body>\n</html>\n","excerpt":"","more":"<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <title>flowchart.js · Playground</title>\n        <style type=\"text/css\">\n          .end-element { background-color : #FFCCFF; }\n        </style>\n        <script src=\"http://cdnjs.cloudflare.com/ajax/libs/raphael/2.1.0/raphael-min.js\"></script>\n        <script src=\"http://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.0/jquery.min.js\"></script>\n        <script src=\"http://flowchart.js.org/flowchart-latest.js\"></script>\n        <!--<script src=\"../release/flowchart.min.js\"></script>-->\n        <script>\n            window.onload = function () {\n                var btn = document.getElementById(\"run\"),\n                    cd = document.getElementById(\"code\"),\n                    chart;\n                (btn.onclick = function () {\n                    var code = cd.value;\n                    if (chart) {\n                      chart.clean();\n                    }\n                    chart = flowchart.parse(code);\n                    chart.drawSVG('canvas', {\n                      // 'x': 30,\n                      // 'y': 50,\n                      'line-width': 3,\n                      'line-length': 50,\n                      'text-margin': 10,\n                      'font-size': 14,\n                      'font': 'normal',\n                      'font-family': 'Helvetica',\n                      'font-weight': 'normal',\n                      'font-color': 'black',\n                      'line-color': 'black',\n                      'element-color': 'black',\n                      'fill': 'white',\n                      'yes-text': 'yes',\n                      'no-text': 'no',\n                      'arrow-end': 'block',\n                      'scale': 1,\n                      'symbols': {\n                        'start': {\n                          'font-color': 'red',\n                          'element-color': 'green',\n                          'fill': 'yellow'\n                        },\n                        'end':{\n                          'class': 'end-element'\n                        }\n                      },\n                      'flowstate' : {\n                        'past' : { 'fill' : '#CCCCCC', 'font-size' : 12},\n                        'current' : {'fill' : 'yellow', 'font-color' : 'red', 'font-weight' : 'bold'},\n                        'future' : { 'fill' : '#FFFF99'},\n                        'request' : { 'fill' : 'blue'},\n                        'invalid': {'fill' : '#444444'},\n                        'approved' : { 'fill' : '#58C4A3', 'font-size' : 12, 'yes-text' : 'APPROVED', 'no-text' : 'n/a' },\n                        'rejected' : { 'fill' : '#C45879', 'font-size' : 12, 'yes-text' : 'n/a', 'no-text' : 'REJECTED' }\n                      }\n                    });\n                    $('[id^=sub1]').click(function(){\n                      alert('info here');\n                    });\n                })();\n            };\n        </script>\n    </head>\n    <body>\n        <div><textarea id=\"code\" style=\"width: 100%;\" rows=\"11\">\nst=>start: Start|past:>http://www.google.com[blank]\ne=>end: End:>http://www.google.com\nop1=>operation: My Operation|past\nop2=>operation: Stuff|current\nsub1=>subroutine: My Subroutine|invalid\ncond=>condition: Yes\nor No?|approved:>http://www.google.com\nc2=>condition: Good idea|rejected\nio=>inputoutput: catch something...|request\n\nst->op1(right)->cond\ncond(yes, right)->c2\ncond(no)->sub1(left)->op1\nc2(yes)->io->e\nc2(no)->op2->e\n        </textarea></div>\n        <div><button id=\"run\" type=\"button\">Run</button></div>\n        <div id=\"canvas\"></div>\n    </body>\n</html>\n"},{"title":"About","date":"2016-10-13T10:10:24.000Z","_content":"\n# About Me\n\n- iOS开发二年级小同学\n- 非科班\n- 仰望星空毕业生\n- 工科男\n","source":"about/index.md","raw":"---\ntitle: About\ndate: 2016-10-13 18:10:24\n---\n\n# About Me\n\n- iOS开发二年级小同学\n- 非科班\n- 仰望星空毕业生\n- 工科男\n","updated":"2016-10-14T08:10:03.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ciudswu8a000ide1asbbvus4n","content":"<h1 id=\"About-Me\"><a href=\"#About-Me\" class=\"headerlink\" title=\"About Me\"></a>About Me</h1><ul>\n<li>iOS开发二年级小同学</li>\n<li>非科班</li>\n<li>仰望星空毕业生</li>\n<li>工科男</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"About-Me\"><a href=\"#About-Me\" class=\"headerlink\" title=\"About Me\"></a>About Me</h1><ul>\n<li>iOS开发二年级小同学</li>\n<li>非科班</li>\n<li>仰望星空毕业生</li>\n<li>工科男</li>\n</ul>\n"}],"Post":[{"title":"AZ-THPerformanceMonitor","date":"2016-10-17T06:39:04.000Z","_content":"\n# AZ-THPerformanceMonitor\n[AZ-THPerformanceMonitor](https://github.com/AndrewZhuCC/AZ-THPerformanceMonitor) 是一个基于 [老谭笔记](http://www.tanhao.me/code/151113.html/) 博客中对 **主线程RunLoop** 卡顿的监控demo，并集成 **CPU使用率** 监控功能的框架。当`RunLoop`耗时超过设定的时间一定次数或者CPU使用率超过一定限度，则会抓取当前所有线程的函数调用栈，以`*.crash`的格式保存在`~/Documents/PerformanceMonitorLogs/`文件夹下。目前开源在 [GitHub](https://github.com/AndrewZhuCC/AZ-THPerformanceMonitor) 上。\n\n## Install\n### - CocoaPods\n[CocoaPods](https://www.cocoapods.org) 是一个管理供 Xcode 使用的开源框架的工具。可以方便的集成、更新开源框架，或者自己私有的框架。\n通过 CocoaPods 将 AZ-THPerformanceMonitor 集成到项目中很简单，把 `pod 'AZ-THPerformanceMonitor', '~> 0.0.7'` 加入到你的 `Podfile` 中即可\n```ruby\nplatform :ios, '7.0'\n\ntarget :YourTarget do\n   pod 'AZ-THPerformanceMonitor', '~> 0.0.7'\nend\n```\n### - Manual\n你也可以手动把 AZ-THPerformanceMonitor 加入到项目中。把 `Class` 目录下的所有文件导入到项目中即可。\n\n## Usage\n```objc\n#import \"AZPerformanceMonitorMarco.h\"\n\n...\n\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    \n    AZPerformanceMonitor *monitor = ObserveRunLoop(1, 10)\n    AZPerformanceMonitor *anotherMonitor = ObserveCPU(90.f, 500)\n    \n    return YES;\n}\n```\n`OberveRunLoop(mostCount, mils)` 是一个便捷启动 **RunLoop监控** 的宏。`mils` 的含义是当主线程的[两个耗时阶段](https://github.com/AndrewZhuCC/AZ-THPerformanceMonitor/blob/master/LICENSE)的**监控耗时触发点**，以毫秒为单位。`mostCount` 的含义是连续出现**耗时超时**则触发抓取动作的次数。\n`ObserveCPU(usage, mils)` 则是启动 **CPU使用率监控** 的宏。`usage` 参数指触发抓取动作的CPU使用率下限，`mils` 是两次监控的时间间隔，以毫秒为单位。\n这两个宏都会返回一个 `AZPerformanceMonitor` 的实例，可以持有该实例，进而可以在适时停止或者暂停监控(*目前抓取所有线程函数调用栈的动作会导致CPU占用率提高30%～40%左右，因此每次触发抓取动作，`AZPerformanceMonitorManager` 会主动暂停所有监控，待抓取动作完成才继续监控*)。也可以通过 `AZPerformanceMonitorManager` 单例来管理所有的监控动作。\n\n## License\n[MIT](https://github.com/AndrewZhuCC/AZ-THPerformanceMonitor/blob/master/LICENSE)\n\n","source":"_posts/AZ-THPerformanceMonitor.md","raw":"---\ntitle: AZ-THPerformanceMonitor\ndate: 2016-10-17 14:39:04\ntags:\n- iOS\n- Framework\n- OpenSource\n---\n\n# AZ-THPerformanceMonitor\n[AZ-THPerformanceMonitor](https://github.com/AndrewZhuCC/AZ-THPerformanceMonitor) 是一个基于 [老谭笔记](http://www.tanhao.me/code/151113.html/) 博客中对 **主线程RunLoop** 卡顿的监控demo，并集成 **CPU使用率** 监控功能的框架。当`RunLoop`耗时超过设定的时间一定次数或者CPU使用率超过一定限度，则会抓取当前所有线程的函数调用栈，以`*.crash`的格式保存在`~/Documents/PerformanceMonitorLogs/`文件夹下。目前开源在 [GitHub](https://github.com/AndrewZhuCC/AZ-THPerformanceMonitor) 上。\n\n## Install\n### - CocoaPods\n[CocoaPods](https://www.cocoapods.org) 是一个管理供 Xcode 使用的开源框架的工具。可以方便的集成、更新开源框架，或者自己私有的框架。\n通过 CocoaPods 将 AZ-THPerformanceMonitor 集成到项目中很简单，把 `pod 'AZ-THPerformanceMonitor', '~> 0.0.7'` 加入到你的 `Podfile` 中即可\n```ruby\nplatform :ios, '7.0'\n\ntarget :YourTarget do\n   pod 'AZ-THPerformanceMonitor', '~> 0.0.7'\nend\n```\n### - Manual\n你也可以手动把 AZ-THPerformanceMonitor 加入到项目中。把 `Class` 目录下的所有文件导入到项目中即可。\n\n## Usage\n```objc\n#import \"AZPerformanceMonitorMarco.h\"\n\n...\n\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    \n    AZPerformanceMonitor *monitor = ObserveRunLoop(1, 10)\n    AZPerformanceMonitor *anotherMonitor = ObserveCPU(90.f, 500)\n    \n    return YES;\n}\n```\n`OberveRunLoop(mostCount, mils)` 是一个便捷启动 **RunLoop监控** 的宏。`mils` 的含义是当主线程的[两个耗时阶段](https://github.com/AndrewZhuCC/AZ-THPerformanceMonitor/blob/master/LICENSE)的**监控耗时触发点**，以毫秒为单位。`mostCount` 的含义是连续出现**耗时超时**则触发抓取动作的次数。\n`ObserveCPU(usage, mils)` 则是启动 **CPU使用率监控** 的宏。`usage` 参数指触发抓取动作的CPU使用率下限，`mils` 是两次监控的时间间隔，以毫秒为单位。\n这两个宏都会返回一个 `AZPerformanceMonitor` 的实例，可以持有该实例，进而可以在适时停止或者暂停监控(*目前抓取所有线程函数调用栈的动作会导致CPU占用率提高30%～40%左右，因此每次触发抓取动作，`AZPerformanceMonitorManager` 会主动暂停所有监控，待抓取动作完成才继续监控*)。也可以通过 `AZPerformanceMonitorManager` 单例来管理所有的监控动作。\n\n## License\n[MIT](https://github.com/AndrewZhuCC/AZ-THPerformanceMonitor/blob/master/LICENSE)\n\n","slug":"AZ-THPerformanceMonitor","published":1,"updated":"2016-10-17T08:01:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudswu6y0001de1a01zsow5i","content":"<h1 id=\"AZ-THPerformanceMonitor\"><a href=\"#AZ-THPerformanceMonitor\" class=\"headerlink\" title=\"AZ-THPerformanceMonitor\"></a>AZ-THPerformanceMonitor</h1><p><a href=\"https://github.com/AndrewZhuCC/AZ-THPerformanceMonitor\" target=\"_blank\" rel=\"external\">AZ-THPerformanceMonitor</a> 是一个基于 <a href=\"http://www.tanhao.me/code/151113.html/\" target=\"_blank\" rel=\"external\">老谭笔记</a> 博客中对 <strong>主线程RunLoop</strong> 卡顿的监控demo，并集成 <strong>CPU使用率</strong> 监控功能的框架。当<code>RunLoop</code>耗时超过设定的时间一定次数或者CPU使用率超过一定限度，则会抓取当前所有线程的函数调用栈，以<code>*.crash</code>的格式保存在<code>~/Documents/PerformanceMonitorLogs/</code>文件夹下。目前开源在 <a href=\"https://github.com/AndrewZhuCC/AZ-THPerformanceMonitor\" target=\"_blank\" rel=\"external\">GitHub</a> 上。</p>\n<h2 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h2><h3 id=\"CocoaPods\"><a href=\"#CocoaPods\" class=\"headerlink\" title=\"- CocoaPods\"></a>- CocoaPods</h3><p><a href=\"https://www.cocoapods.org\" target=\"_blank\" rel=\"external\">CocoaPods</a> 是一个管理供 Xcode 使用的开源框架的工具。可以方便的集成、更新开源框架，或者自己私有的框架。<br>通过 CocoaPods 将 AZ-THPerformanceMonitor 集成到项目中很简单，把 <code>pod &#39;AZ-THPerformanceMonitor&#39;, &#39;~&gt; 0.0.7&#39;</code> 加入到你的 <code>Podfile</code> 中即可<br><figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><div class=\"line\">platform <span class=\"symbol\">:ios</span>, <span class=\"string\">'7.0'</span></div><div class=\"line\"></div><div class=\"line\">target <span class=\"symbol\">:YourTarget</span> <span class=\"keyword\">do</span></div><div class=\"line\">   pod <span class=\"string\">'AZ-THPerformanceMonitor'</span>, <span class=\"string\">'~&gt; 0.0.7'</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"Manual\"><a href=\"#Manual\" class=\"headerlink\" title=\"- Manual\"></a>- Manual</h3><p>你也可以手动把 AZ-THPerformanceMonitor 加入到项目中。把 <code>Class</code> 目录下的所有文件导入到项目中即可。</p>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"AZPerformanceMonitorMarco.h\"</span></span></div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</div><div class=\"line\">    </div><div class=\"line\">    AZPerformanceMonitor *monitor = ObserveRunLoop(<span class=\"number\">1</span>, <span class=\"number\">10</span>)</div><div class=\"line\">    AZPerformanceMonitor *anotherMonitor = ObserveCPU(<span class=\"number\">90.</span>f, <span class=\"number\">500</span>)</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>OberveRunLoop(mostCount, mils)</code> 是一个便捷启动 <strong>RunLoop监控</strong> 的宏。<code>mils</code> 的含义是当主线程的<a href=\"https://github.com/AndrewZhuCC/AZ-THPerformanceMonitor/blob/master/LICENSE\" target=\"_blank\" rel=\"external\">两个耗时阶段</a>的<strong>监控耗时触发点</strong>，以毫秒为单位。<code>mostCount</code> 的含义是连续出现<strong>耗时超时</strong>则触发抓取动作的次数。<br><code>ObserveCPU(usage, mils)</code> 则是启动 <strong>CPU使用率监控</strong> 的宏。<code>usage</code> 参数指触发抓取动作的CPU使用率下限，<code>mils</code> 是两次监控的时间间隔，以毫秒为单位。<br>这两个宏都会返回一个 <code>AZPerformanceMonitor</code> 的实例，可以持有该实例，进而可以在适时停止或者暂停监控(<em>目前抓取所有线程函数调用栈的动作会导致CPU占用率提高30%～40%左右，因此每次触发抓取动作，<code>AZPerformanceMonitorManager</code> 会主动暂停所有监控，待抓取动作完成才继续监控</em>)。也可以通过 <code>AZPerformanceMonitorManager</code> 单例来管理所有的监控动作。</p>\n<h2 id=\"License\"><a href=\"#License\" class=\"headerlink\" title=\"License\"></a>License</h2><p><a href=\"https://github.com/AndrewZhuCC/AZ-THPerformanceMonitor/blob/master/LICENSE\" target=\"_blank\" rel=\"external\">MIT</a></p>\n","excerpt":"","more":"<h1 id=\"AZ-THPerformanceMonitor\"><a href=\"#AZ-THPerformanceMonitor\" class=\"headerlink\" title=\"AZ-THPerformanceMonitor\"></a>AZ-THPerformanceMonitor</h1><p><a href=\"https://github.com/AndrewZhuCC/AZ-THPerformanceMonitor\">AZ-THPerformanceMonitor</a> 是一个基于 <a href=\"http://www.tanhao.me/code/151113.html/\">老谭笔记</a> 博客中对 <strong>主线程RunLoop</strong> 卡顿的监控demo，并集成 <strong>CPU使用率</strong> 监控功能的框架。当<code>RunLoop</code>耗时超过设定的时间一定次数或者CPU使用率超过一定限度，则会抓取当前所有线程的函数调用栈，以<code>*.crash</code>的格式保存在<code>~/Documents/PerformanceMonitorLogs/</code>文件夹下。目前开源在 <a href=\"https://github.com/AndrewZhuCC/AZ-THPerformanceMonitor\">GitHub</a> 上。</p>\n<h2 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h2><h3 id=\"CocoaPods\"><a href=\"#CocoaPods\" class=\"headerlink\" title=\"- CocoaPods\"></a>- CocoaPods</h3><p><a href=\"https://www.cocoapods.org\">CocoaPods</a> 是一个管理供 Xcode 使用的开源框架的工具。可以方便的集成、更新开源框架，或者自己私有的框架。<br>通过 CocoaPods 将 AZ-THPerformanceMonitor 集成到项目中很简单，把 <code>pod &#39;AZ-THPerformanceMonitor&#39;, &#39;~&gt; 0.0.7&#39;</code> 加入到你的 <code>Podfile</code> 中即可<br><figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><div class=\"line\">platform <span class=\"symbol\">:ios</span>, <span class=\"string\">'7.0'</span></div><div class=\"line\"></div><div class=\"line\">target <span class=\"symbol\">:YourTarget</span> <span class=\"keyword\">do</span></div><div class=\"line\">   pod <span class=\"string\">'AZ-THPerformanceMonitor'</span>, <span class=\"string\">'~&gt; 0.0.7'</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"Manual\"><a href=\"#Manual\" class=\"headerlink\" title=\"- Manual\"></a>- Manual</h3><p>你也可以手动把 AZ-THPerformanceMonitor 加入到项目中。把 <code>Class</code> 目录下的所有文件导入到项目中即可。</p>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"AZPerformanceMonitorMarco.h\"</span></span></div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</div><div class=\"line\">    </div><div class=\"line\">    AZPerformanceMonitor *monitor = ObserveRunLoop(<span class=\"number\">1</span>, <span class=\"number\">10</span>)</div><div class=\"line\">    AZPerformanceMonitor *anotherMonitor = ObserveCPU(<span class=\"number\">90.</span>f, <span class=\"number\">500</span>)</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>OberveRunLoop(mostCount, mils)</code> 是一个便捷启动 <strong>RunLoop监控</strong> 的宏。<code>mils</code> 的含义是当主线程的<a href=\"https://github.com/AndrewZhuCC/AZ-THPerformanceMonitor/blob/master/LICENSE\">两个耗时阶段</a>的<strong>监控耗时触发点</strong>，以毫秒为单位。<code>mostCount</code> 的含义是连续出现<strong>耗时超时</strong>则触发抓取动作的次数。<br><code>ObserveCPU(usage, mils)</code> 则是启动 <strong>CPU使用率监控</strong> 的宏。<code>usage</code> 参数指触发抓取动作的CPU使用率下限，<code>mils</code> 是两次监控的时间间隔，以毫秒为单位。<br>这两个宏都会返回一个 <code>AZPerformanceMonitor</code> 的实例，可以持有该实例，进而可以在适时停止或者暂停监控(<em>目前抓取所有线程函数调用栈的动作会导致CPU占用率提高30%～40%左右，因此每次触发抓取动作，<code>AZPerformanceMonitorManager</code> 会主动暂停所有监控，待抓取动作完成才继续监控</em>)。也可以通过 <code>AZPerformanceMonitorManager</code> 单例来管理所有的监控动作。</p>\n<h2 id=\"License\"><a href=\"#License\" class=\"headerlink\" title=\"License\"></a>License</h2><p><a href=\"https://github.com/AndrewZhuCC/AZ-THPerformanceMonitor/blob/master/LICENSE\">MIT</a></p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2016-10-13T09:48:07.000Z","updated":"2016-10-13T09:48:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudswu730003de1a75rg4w6g","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n"},{"title":"老谭笔记-RunLoop","date":"2016-10-17T08:02:48.000Z","_content":"\n# AZ-THPerformanceMonitor\n\n>from [老谭笔记](http://www.tanhao.me/code/151113.html/)\n\n## iOS 实时卡顿监控\n\n>在移动设备上开发软件,性能一直是我们最为关心的话题之一,我们作为程序员除了需要努力提高代码质量之外,及时发现和监控软件中那些造成性能低下的”罪魁祸首”也是我们神圣的职责.\n\n众所周知,iOS平台因为UIKit本身的特性,需要将所有的UI操作都放在主线程执行,所以也造成不少程序员都习惯将一些线程安全性不确定的逻辑,以及其它线程结束后的汇总工作等等放到了主线,所以主线程中包含的这些大量计算、IO、绘制都有可能造成卡顿.\n\n在Xcode中已经集成了非常方便的调试工具Instruments,它可以帮助我们在开发测试阶段分析软件运行的性能消耗,但一款软件经过测试流程和实验室分析肯定是不够的,在正式环境中由大量用户在使用过程中监控、分析到的数据更能解决一些隐藏的问题.\n\n<br />\n\n### 寻找卡顿的切入点\n>监控卡顿,最直接就是找到主线程都在干些啥玩意儿.我们知道一个线程的消息事件处理都是依赖于NSRunLoop来驱动,所以要知道线程正在调用什么方法,就需要从NSRunLoop来入手.CFRunLoop的代码是开源,可以在[此处](http://opensource.apple.com/source/CF/CF-1151.16/CFRunLoop.c)查阅到源代码,其中核心方法CFRunLoopRun简化后的主要逻辑大概是这样的:\n<br />\n\n```objc\nint32_t __CFRunLoopRun()\n{\n    //通知即将进入runloop\n    __CFRunLoopDoObservers(KCFRunLoopEntry);\n    \n    do\n    {\n        // 通知将要处理timer和source\n        __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);\n        __CFRunLoopDoObservers(kCFRunLoopBeforeSources);\n        \n        __CFRunLoopDoBlocks();  //处理非延迟的主线程调用\n        __CFRunLoopDoSource0(); //处理UIEvent事件\n        \n        //GCD dispatch main queue\n        CheckIfExistMessagesInMainDispatchQueue();\n        \n        // 即将进入休眠\n        __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting);\n        \n        // 等待内核mach_msg事件\n        mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts();\n        \n        // Zzz...\n        \n        // 从等待中醒来\n        __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);\n        \n        // 处理因timer的唤醒\n        if (wakeUpPort == timerPort)\n            __CFRunLoopDoTimers();\n        \n        // 处理异步方法唤醒,如dispatch_async\n        else if (wakeUpPort == mainDispatchQueuePort)\n            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()\n            \n        // UI刷新,动画显示\n        else\n            __CFRunLoopDoSource1();\n        \n        // 再次确保是否有同步的方法需要调用\n        __CFRunLoopDoBlocks();\n        \n    } while (!stop && !timeout);\n    \n    //通知即将退出runloop\n    __CFRunLoopDoObservers(CFRunLoopExit);\n}\n```\n<br />\n\n>不难发现NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.\n\n<br />\n\n### 量化卡顿的程度\n>要监控NSRunLoop的状态,我们需要使用到CFRunLoopObserverRef,通过它可以实时获得这些状态值的变化,具体的使用如下:\n>\n\n<br />\n\n```objc\nstatic void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)\n{\n    MyClass *object = (__bridge MyClass*)info;\n    object->activity = activity;\n}\n\n- (void)registerObserver\n{\n    CFRunLoopObserverContext context = {0,(__bridge void*)self,NULL,NULL};\n    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,\n                                                            kCFRunLoopAllActivities,\n                                                            YES,\n                                                            0,\n                                                            &runLoopObserverCallBack,\n                                                            &context);\n    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);\n}\n```\n<br />\n\n>只需要另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手.\n为了让计算更精确,需要让子线程更及时的获知主线程NSRunLoop状态变化,所以dispatch_semaphore_t是个不错的选择,另外卡顿需要覆盖到多次连续小卡顿和单次长时间卡顿两种情景,所以判定条件也需要做适当优化.将上面两个方法添加计算的逻辑如下:\n\n<br />\n\n```objc\nstatic void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)\n{\n    MyClass *object = (__bridge MyClass*)info;\n    \n    // 记录状态值\n    object->activity = activity;\n    \n    // 发送信号\n    dispatch_semaphore_t semaphore = moniotr->semaphore;\n    dispatch_semaphore_signal(semaphore);\n}\n\n- (void)registerObserver\n{\n    CFRunLoopObserverContext context = {0,(__bridge void*)self,NULL,NULL};\n    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,\n                                                            kCFRunLoopAllActivities,\n                                                            YES,\n                                                            0,\n                                                            &runLoopObserverCallBack,\n                                                            &context);\n    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);\n    \n    // 创建信号\n    semaphore = dispatch_semaphore_create(0);\n    \n    // 在子线程监控时长\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        while (YES)\n        {\n            // 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)\n            long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));\n            if (st != 0)\n            {\n                if (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting)\n                {\n                    if (++timeoutCount < 5)\n                        continue;\n                    \n                    NSLog(@\"好像有点儿卡哦\");\n                }\n            }\n            timeoutCount = 0;\n        }\n    });\n}\n```\n### 记录卡顿的函数调用\n\n<br />\n\n>监控到了卡顿现场,当然下一步便是记录此时的函数调用信息,此处可以使用一个第三方Crash收集组件PLCrashReporter,它不仅可以收集Crash信息也可用于实时获取各线程的调用堆栈,使用示例如下:\n\n<br />\n\n```objc\nPLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD\n                                                                   symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];\nPLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration:config];\n\nNSData *data = [crashReporter generateLiveReport];\nPLCrashReport *reporter = [[PLCrashReport alloc] initWithData:data error:NULL];\nNSString *report = [PLCrashReportTextFormatter stringValueForCrashReport:reporter\n                                                          withTextFormat:PLCrashReportTextFormatiOS];\n\nNSLog(@\"------------\\n%@\\n------------\", report);\n```\n当检测到卡顿时,抓取堆栈信息,然后在客户端做一些过滤处理,便可以上报到服务器,通过收集一定量的卡顿数据后经过分析便能准确定位需要优化的逻辑,至此这个实时卡顿监控就大功告成了!\n\n","source":"_posts/ltpost.md","raw":"---\ntitle: 老谭笔记-RunLoop\ndate: 2016-10-17 16:02:48\ntags:\n- iOS\n---\n\n# AZ-THPerformanceMonitor\n\n>from [老谭笔记](http://www.tanhao.me/code/151113.html/)\n\n## iOS 实时卡顿监控\n\n>在移动设备上开发软件,性能一直是我们最为关心的话题之一,我们作为程序员除了需要努力提高代码质量之外,及时发现和监控软件中那些造成性能低下的”罪魁祸首”也是我们神圣的职责.\n\n众所周知,iOS平台因为UIKit本身的特性,需要将所有的UI操作都放在主线程执行,所以也造成不少程序员都习惯将一些线程安全性不确定的逻辑,以及其它线程结束后的汇总工作等等放到了主线,所以主线程中包含的这些大量计算、IO、绘制都有可能造成卡顿.\n\n在Xcode中已经集成了非常方便的调试工具Instruments,它可以帮助我们在开发测试阶段分析软件运行的性能消耗,但一款软件经过测试流程和实验室分析肯定是不够的,在正式环境中由大量用户在使用过程中监控、分析到的数据更能解决一些隐藏的问题.\n\n<br />\n\n### 寻找卡顿的切入点\n>监控卡顿,最直接就是找到主线程都在干些啥玩意儿.我们知道一个线程的消息事件处理都是依赖于NSRunLoop来驱动,所以要知道线程正在调用什么方法,就需要从NSRunLoop来入手.CFRunLoop的代码是开源,可以在[此处](http://opensource.apple.com/source/CF/CF-1151.16/CFRunLoop.c)查阅到源代码,其中核心方法CFRunLoopRun简化后的主要逻辑大概是这样的:\n<br />\n\n```objc\nint32_t __CFRunLoopRun()\n{\n    //通知即将进入runloop\n    __CFRunLoopDoObservers(KCFRunLoopEntry);\n    \n    do\n    {\n        // 通知将要处理timer和source\n        __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);\n        __CFRunLoopDoObservers(kCFRunLoopBeforeSources);\n        \n        __CFRunLoopDoBlocks();  //处理非延迟的主线程调用\n        __CFRunLoopDoSource0(); //处理UIEvent事件\n        \n        //GCD dispatch main queue\n        CheckIfExistMessagesInMainDispatchQueue();\n        \n        // 即将进入休眠\n        __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting);\n        \n        // 等待内核mach_msg事件\n        mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts();\n        \n        // Zzz...\n        \n        // 从等待中醒来\n        __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);\n        \n        // 处理因timer的唤醒\n        if (wakeUpPort == timerPort)\n            __CFRunLoopDoTimers();\n        \n        // 处理异步方法唤醒,如dispatch_async\n        else if (wakeUpPort == mainDispatchQueuePort)\n            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()\n            \n        // UI刷新,动画显示\n        else\n            __CFRunLoopDoSource1();\n        \n        // 再次确保是否有同步的方法需要调用\n        __CFRunLoopDoBlocks();\n        \n    } while (!stop && !timeout);\n    \n    //通知即将退出runloop\n    __CFRunLoopDoObservers(CFRunLoopExit);\n}\n```\n<br />\n\n>不难发现NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.\n\n<br />\n\n### 量化卡顿的程度\n>要监控NSRunLoop的状态,我们需要使用到CFRunLoopObserverRef,通过它可以实时获得这些状态值的变化,具体的使用如下:\n>\n\n<br />\n\n```objc\nstatic void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)\n{\n    MyClass *object = (__bridge MyClass*)info;\n    object->activity = activity;\n}\n\n- (void)registerObserver\n{\n    CFRunLoopObserverContext context = {0,(__bridge void*)self,NULL,NULL};\n    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,\n                                                            kCFRunLoopAllActivities,\n                                                            YES,\n                                                            0,\n                                                            &runLoopObserverCallBack,\n                                                            &context);\n    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);\n}\n```\n<br />\n\n>只需要另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手.\n为了让计算更精确,需要让子线程更及时的获知主线程NSRunLoop状态变化,所以dispatch_semaphore_t是个不错的选择,另外卡顿需要覆盖到多次连续小卡顿和单次长时间卡顿两种情景,所以判定条件也需要做适当优化.将上面两个方法添加计算的逻辑如下:\n\n<br />\n\n```objc\nstatic void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)\n{\n    MyClass *object = (__bridge MyClass*)info;\n    \n    // 记录状态值\n    object->activity = activity;\n    \n    // 发送信号\n    dispatch_semaphore_t semaphore = moniotr->semaphore;\n    dispatch_semaphore_signal(semaphore);\n}\n\n- (void)registerObserver\n{\n    CFRunLoopObserverContext context = {0,(__bridge void*)self,NULL,NULL};\n    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,\n                                                            kCFRunLoopAllActivities,\n                                                            YES,\n                                                            0,\n                                                            &runLoopObserverCallBack,\n                                                            &context);\n    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);\n    \n    // 创建信号\n    semaphore = dispatch_semaphore_create(0);\n    \n    // 在子线程监控时长\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        while (YES)\n        {\n            // 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)\n            long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));\n            if (st != 0)\n            {\n                if (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting)\n                {\n                    if (++timeoutCount < 5)\n                        continue;\n                    \n                    NSLog(@\"好像有点儿卡哦\");\n                }\n            }\n            timeoutCount = 0;\n        }\n    });\n}\n```\n### 记录卡顿的函数调用\n\n<br />\n\n>监控到了卡顿现场,当然下一步便是记录此时的函数调用信息,此处可以使用一个第三方Crash收集组件PLCrashReporter,它不仅可以收集Crash信息也可用于实时获取各线程的调用堆栈,使用示例如下:\n\n<br />\n\n```objc\nPLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD\n                                                                   symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];\nPLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration:config];\n\nNSData *data = [crashReporter generateLiveReport];\nPLCrashReport *reporter = [[PLCrashReport alloc] initWithData:data error:NULL];\nNSString *report = [PLCrashReportTextFormatter stringValueForCrashReport:reporter\n                                                          withTextFormat:PLCrashReportTextFormatiOS];\n\nNSLog(@\"------------\\n%@\\n------------\", report);\n```\n当检测到卡顿时,抓取堆栈信息,然后在客户端做一些过滤处理,便可以上报到服务器,通过收集一定量的卡顿数据后经过分析便能准确定位需要优化的逻辑,至此这个实时卡顿监控就大功告成了!\n\n","slug":"ltpost","published":1,"updated":"2016-10-17T08:19:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudswu790005de1ar9yk0whc","content":"<h1 id=\"AZ-THPerformanceMonitor\"><a href=\"#AZ-THPerformanceMonitor\" class=\"headerlink\" title=\"AZ-THPerformanceMonitor\"></a>AZ-THPerformanceMonitor</h1><blockquote>\n<p>from <a href=\"http://www.tanhao.me/code/151113.html/\" target=\"_blank\" rel=\"external\">老谭笔记</a></p>\n</blockquote>\n<h2 id=\"iOS-实时卡顿监控\"><a href=\"#iOS-实时卡顿监控\" class=\"headerlink\" title=\"iOS 实时卡顿监控\"></a>iOS 实时卡顿监控</h2><blockquote>\n<p>在移动设备上开发软件,性能一直是我们最为关心的话题之一,我们作为程序员除了需要努力提高代码质量之外,及时发现和监控软件中那些造成性能低下的”罪魁祸首”也是我们神圣的职责.</p>\n</blockquote>\n<p>众所周知,iOS平台因为UIKit本身的特性,需要将所有的UI操作都放在主线程执行,所以也造成不少程序员都习惯将一些线程安全性不确定的逻辑,以及其它线程结束后的汇总工作等等放到了主线,所以主线程中包含的这些大量计算、IO、绘制都有可能造成卡顿.</p>\n<p>在Xcode中已经集成了非常方便的调试工具Instruments,它可以帮助我们在开发测试阶段分析软件运行的性能消耗,但一款软件经过测试流程和实验室分析肯定是不够的,在正式环境中由大量用户在使用过程中监控、分析到的数据更能解决一些隐藏的问题.</p>\n<p><br></p>\n<h3 id=\"寻找卡顿的切入点\"><a href=\"#寻找卡顿的切入点\" class=\"headerlink\" title=\"寻找卡顿的切入点\"></a>寻找卡顿的切入点</h3><blockquote>\n<p>监控卡顿,最直接就是找到主线程都在干些啥玩意儿.我们知道一个线程的消息事件处理都是依赖于NSRunLoop来驱动,所以要知道线程正在调用什么方法,就需要从NSRunLoop来入手.CFRunLoop的代码是开源,可以在<a href=\"http://opensource.apple.com/source/CF/CF-1151.16/CFRunLoop.c\" target=\"_blank\" rel=\"external\">此处</a>查阅到源代码,其中核心方法CFRunLoopRun简化后的主要逻辑大概是这样的:<br><br></p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><div class=\"line\">int32_t __CFRunLoopRun()</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//通知即将进入runloop</span></div><div class=\"line\">    __CFRunLoopDoObservers(KCFRunLoopEntry);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">do</span></div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"comment\">// 通知将要处理timer和source</span></div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);</div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopBeforeSources);</div><div class=\"line\">        </div><div class=\"line\">        __CFRunLoopDoBlocks();  <span class=\"comment\">//处理非延迟的主线程调用</span></div><div class=\"line\">        __CFRunLoopDoSource0(); <span class=\"comment\">//处理UIEvent事件</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//GCD dispatch main queue</span></div><div class=\"line\">        CheckIfExistMessagesInMainDispatchQueue();</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 即将进入休眠</span></div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 等待内核mach_msg事件</span></div><div class=\"line\">        mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts();</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// Zzz...</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 从等待中醒来</span></div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 处理因timer的唤醒</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (wakeUpPort == timerPort)</div><div class=\"line\">            __CFRunLoopDoTimers();</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 处理异步方法唤醒,如dispatch_async</span></div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (wakeUpPort == mainDispatchQueuePort)</div><div class=\"line\">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</div><div class=\"line\">            </div><div class=\"line\">        <span class=\"comment\">// UI刷新,动画显示</span></div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            __CFRunLoopDoSource1();</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 再次确保是否有同步的方法需要调用</span></div><div class=\"line\">        __CFRunLoopDoBlocks();</div><div class=\"line\">        </div><div class=\"line\">    &#125; <span class=\"keyword\">while</span> (!stop &amp;&amp; !timeout);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//通知即将退出runloop</span></div><div class=\"line\">    __CFRunLoopDoObservers(<span class=\"built_in\">CFRunLoopExit</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><br></p>\n<blockquote>\n<p>不难发现NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.</p>\n</blockquote>\n<p><br></p>\n<h3 id=\"量化卡顿的程度\"><a href=\"#量化卡顿的程度\" class=\"headerlink\" title=\"量化卡顿的程度\"></a>量化卡顿的程度</h3><blockquote>\n<p>要监控NSRunLoop的状态,我们需要使用到CFRunLoopObserverRef,通过它可以实时获得这些状态值的变化,具体的使用如下:</p>\n</blockquote>\n<p><br></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> runLoopObserverCallBack(<span class=\"built_in\">CFRunLoopObserverRef</span> observer, <span class=\"built_in\">CFRunLoopActivity</span> activity, <span class=\"keyword\">void</span> *info)</div><div class=\"line\">&#123;</div><div class=\"line\">    MyClass *object = (__bridge MyClass*)info;</div><div class=\"line\">    object-&gt;activity = activity;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)registerObserver</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">CFRunLoopObserverContext</span> context = &#123;<span class=\"number\">0</span>,(__bridge <span class=\"keyword\">void</span>*)<span class=\"keyword\">self</span>,<span class=\"literal\">NULL</span>,<span class=\"literal\">NULL</span>&#125;;</div><div class=\"line\">    <span class=\"built_in\">CFRunLoopObserverRef</span> observer = <span class=\"built_in\">CFRunLoopObserverCreate</span>(kCFAllocatorDefault,</div><div class=\"line\">                                                            kCFRunLoopAllActivities,</div><div class=\"line\">                                                            <span class=\"literal\">YES</span>,</div><div class=\"line\">                                                            <span class=\"number\">0</span>,</div><div class=\"line\">                                                            &amp;runLoopObserverCallBack,</div><div class=\"line\">                                                            &amp;context);</div><div class=\"line\">    <span class=\"built_in\">CFRunLoopAddObserver</span>(<span class=\"built_in\">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><br></p>\n<blockquote>\n<p>只需要另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手.<br>为了让计算更精确,需要让子线程更及时的获知主线程NSRunLoop状态变化,所以dispatch_semaphore_t是个不错的选择,另外卡顿需要覆盖到多次连续小卡顿和单次长时间卡顿两种情景,所以判定条件也需要做适当优化.将上面两个方法添加计算的逻辑如下:</p>\n</blockquote>\n<p><br></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> runLoopObserverCallBack(<span class=\"built_in\">CFRunLoopObserverRef</span> observer, <span class=\"built_in\">CFRunLoopActivity</span> activity, <span class=\"keyword\">void</span> *info)</div><div class=\"line\">&#123;</div><div class=\"line\">    MyClass *object = (__bridge MyClass*)info;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 记录状态值</span></div><div class=\"line\">    object-&gt;activity = activity;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 发送信号</span></div><div class=\"line\">    dispatch_semaphore_t semaphore = moniotr-&gt;semaphore;</div><div class=\"line\">    dispatch_semaphore_signal(semaphore);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)registerObserver</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">CFRunLoopObserverContext</span> context = &#123;<span class=\"number\">0</span>,(__bridge <span class=\"keyword\">void</span>*)<span class=\"keyword\">self</span>,<span class=\"literal\">NULL</span>,<span class=\"literal\">NULL</span>&#125;;</div><div class=\"line\">    <span class=\"built_in\">CFRunLoopObserverRef</span> observer = <span class=\"built_in\">CFRunLoopObserverCreate</span>(kCFAllocatorDefault,</div><div class=\"line\">                                                            kCFRunLoopAllActivities,</div><div class=\"line\">                                                            <span class=\"literal\">YES</span>,</div><div class=\"line\">                                                            <span class=\"number\">0</span>,</div><div class=\"line\">                                                            &amp;runLoopObserverCallBack,</div><div class=\"line\">                                                            &amp;context);</div><div class=\"line\">    <span class=\"built_in\">CFRunLoopAddObserver</span>(<span class=\"built_in\">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 创建信号</span></div><div class=\"line\">    semaphore = dispatch_semaphore_create(<span class=\"number\">0</span>);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 在子线程监控时长</span></div><div class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">YES</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"comment\">// 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)</span></div><div class=\"line\">            <span class=\"keyword\">long</span> st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, <span class=\"number\">50</span>*<span class=\"built_in\">NSEC_PER_MSEC</span>));</div><div class=\"line\">            <span class=\"keyword\">if</span> (st != <span class=\"number\">0</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (++timeoutCount &lt; <span class=\"number\">5</span>)</div><div class=\"line\">                        <span class=\"keyword\">continue</span>;</div><div class=\"line\">                    </div><div class=\"line\">                    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"好像有点儿卡哦\"</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            timeoutCount = <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"记录卡顿的函数调用\"><a href=\"#记录卡顿的函数调用\" class=\"headerlink\" title=\"记录卡顿的函数调用\"></a>记录卡顿的函数调用</h3><p><br></p>\n<blockquote>\n<p>监控到了卡顿现场,当然下一步便是记录此时的函数调用信息,此处可以使用一个第三方Crash收集组件PLCrashReporter,它不仅可以收集Crash信息也可用于实时获取各线程的调用堆栈,使用示例如下:</p>\n</blockquote>\n<p><br></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><div class=\"line\">PLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD</div><div class=\"line\">                                                                   symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];</div><div class=\"line\">PLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration:config];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSData</span> *data = [crashReporter generateLiveReport];</div><div class=\"line\">PLCrashReport *reporter = [[PLCrashReport alloc] initWithData:data error:<span class=\"literal\">NULL</span>];</div><div class=\"line\"><span class=\"built_in\">NSString</span> *report = [PLCrashReportTextFormatter stringValueForCrashReport:reporter</div><div class=\"line\">                                                          withTextFormat:PLCrashReportTextFormatiOS];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"------------\\n%@\\n------------\"</span>, report);</div></pre></td></tr></table></figure>\n<p>当检测到卡顿时,抓取堆栈信息,然后在客户端做一些过滤处理,便可以上报到服务器,通过收集一定量的卡顿数据后经过分析便能准确定位需要优化的逻辑,至此这个实时卡顿监控就大功告成了!</p>\n","excerpt":"","more":"<h1 id=\"AZ-THPerformanceMonitor\"><a href=\"#AZ-THPerformanceMonitor\" class=\"headerlink\" title=\"AZ-THPerformanceMonitor\"></a>AZ-THPerformanceMonitor</h1><blockquote>\n<p>from <a href=\"http://www.tanhao.me/code/151113.html/\">老谭笔记</a></p>\n</blockquote>\n<h2 id=\"iOS-实时卡顿监控\"><a href=\"#iOS-实时卡顿监控\" class=\"headerlink\" title=\"iOS 实时卡顿监控\"></a>iOS 实时卡顿监控</h2><blockquote>\n<p>在移动设备上开发软件,性能一直是我们最为关心的话题之一,我们作为程序员除了需要努力提高代码质量之外,及时发现和监控软件中那些造成性能低下的”罪魁祸首”也是我们神圣的职责.</p>\n</blockquote>\n<p>众所周知,iOS平台因为UIKit本身的特性,需要将所有的UI操作都放在主线程执行,所以也造成不少程序员都习惯将一些线程安全性不确定的逻辑,以及其它线程结束后的汇总工作等等放到了主线,所以主线程中包含的这些大量计算、IO、绘制都有可能造成卡顿.</p>\n<p>在Xcode中已经集成了非常方便的调试工具Instruments,它可以帮助我们在开发测试阶段分析软件运行的性能消耗,但一款软件经过测试流程和实验室分析肯定是不够的,在正式环境中由大量用户在使用过程中监控、分析到的数据更能解决一些隐藏的问题.</p>\n<p><br /></p>\n<h3 id=\"寻找卡顿的切入点\"><a href=\"#寻找卡顿的切入点\" class=\"headerlink\" title=\"寻找卡顿的切入点\"></a>寻找卡顿的切入点</h3><blockquote>\n<p>监控卡顿,最直接就是找到主线程都在干些啥玩意儿.我们知道一个线程的消息事件处理都是依赖于NSRunLoop来驱动,所以要知道线程正在调用什么方法,就需要从NSRunLoop来入手.CFRunLoop的代码是开源,可以在<a href=\"http://opensource.apple.com/source/CF/CF-1151.16/CFRunLoop.c\">此处</a>查阅到源代码,其中核心方法CFRunLoopRun简化后的主要逻辑大概是这样的:<br><br /></p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><div class=\"line\">int32_t __CFRunLoopRun()</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//通知即将进入runloop</span></div><div class=\"line\">    __CFRunLoopDoObservers(KCFRunLoopEntry);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">do</span></div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"comment\">// 通知将要处理timer和source</span></div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);</div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopBeforeSources);</div><div class=\"line\">        </div><div class=\"line\">        __CFRunLoopDoBlocks();  <span class=\"comment\">//处理非延迟的主线程调用</span></div><div class=\"line\">        __CFRunLoopDoSource0(); <span class=\"comment\">//处理UIEvent事件</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//GCD dispatch main queue</span></div><div class=\"line\">        CheckIfExistMessagesInMainDispatchQueue();</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 即将进入休眠</span></div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 等待内核mach_msg事件</span></div><div class=\"line\">        mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts();</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// Zzz...</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 从等待中醒来</span></div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 处理因timer的唤醒</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (wakeUpPort == timerPort)</div><div class=\"line\">            __CFRunLoopDoTimers();</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 处理异步方法唤醒,如dispatch_async</span></div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (wakeUpPort == mainDispatchQueuePort)</div><div class=\"line\">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</div><div class=\"line\">            </div><div class=\"line\">        <span class=\"comment\">// UI刷新,动画显示</span></div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            __CFRunLoopDoSource1();</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 再次确保是否有同步的方法需要调用</span></div><div class=\"line\">        __CFRunLoopDoBlocks();</div><div class=\"line\">        </div><div class=\"line\">    &#125; <span class=\"keyword\">while</span> (!stop &amp;&amp; !timeout);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//通知即将退出runloop</span></div><div class=\"line\">    __CFRunLoopDoObservers(<span class=\"built_in\">CFRunLoopExit</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><br /></p>\n<blockquote>\n<p>不难发现NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.</p>\n</blockquote>\n<p><br /></p>\n<h3 id=\"量化卡顿的程度\"><a href=\"#量化卡顿的程度\" class=\"headerlink\" title=\"量化卡顿的程度\"></a>量化卡顿的程度</h3><blockquote>\n<p>要监控NSRunLoop的状态,我们需要使用到CFRunLoopObserverRef,通过它可以实时获得这些状态值的变化,具体的使用如下:</p>\n</blockquote>\n<p><br /></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> runLoopObserverCallBack(<span class=\"built_in\">CFRunLoopObserverRef</span> observer, <span class=\"built_in\">CFRunLoopActivity</span> activity, <span class=\"keyword\">void</span> *info)</div><div class=\"line\">&#123;</div><div class=\"line\">    MyClass *object = (__bridge MyClass*)info;</div><div class=\"line\">    object-&gt;activity = activity;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)registerObserver</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">CFRunLoopObserverContext</span> context = &#123;<span class=\"number\">0</span>,(__bridge <span class=\"keyword\">void</span>*)<span class=\"keyword\">self</span>,<span class=\"literal\">NULL</span>,<span class=\"literal\">NULL</span>&#125;;</div><div class=\"line\">    <span class=\"built_in\">CFRunLoopObserverRef</span> observer = <span class=\"built_in\">CFRunLoopObserverCreate</span>(kCFAllocatorDefault,</div><div class=\"line\">                                                            kCFRunLoopAllActivities,</div><div class=\"line\">                                                            <span class=\"literal\">YES</span>,</div><div class=\"line\">                                                            <span class=\"number\">0</span>,</div><div class=\"line\">                                                            &amp;runLoopObserverCallBack,</div><div class=\"line\">                                                            &amp;context);</div><div class=\"line\">    <span class=\"built_in\">CFRunLoopAddObserver</span>(<span class=\"built_in\">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><br /></p>\n<blockquote>\n<p>只需要另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手.<br>为了让计算更精确,需要让子线程更及时的获知主线程NSRunLoop状态变化,所以dispatch_semaphore_t是个不错的选择,另外卡顿需要覆盖到多次连续小卡顿和单次长时间卡顿两种情景,所以判定条件也需要做适当优化.将上面两个方法添加计算的逻辑如下:</p>\n</blockquote>\n<p><br /></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> runLoopObserverCallBack(<span class=\"built_in\">CFRunLoopObserverRef</span> observer, <span class=\"built_in\">CFRunLoopActivity</span> activity, <span class=\"keyword\">void</span> *info)</div><div class=\"line\">&#123;</div><div class=\"line\">    MyClass *object = (__bridge MyClass*)info;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 记录状态值</span></div><div class=\"line\">    object-&gt;activity = activity;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 发送信号</span></div><div class=\"line\">    dispatch_semaphore_t semaphore = moniotr-&gt;semaphore;</div><div class=\"line\">    dispatch_semaphore_signal(semaphore);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)registerObserver</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">CFRunLoopObserverContext</span> context = &#123;<span class=\"number\">0</span>,(__bridge <span class=\"keyword\">void</span>*)<span class=\"keyword\">self</span>,<span class=\"literal\">NULL</span>,<span class=\"literal\">NULL</span>&#125;;</div><div class=\"line\">    <span class=\"built_in\">CFRunLoopObserverRef</span> observer = <span class=\"built_in\">CFRunLoopObserverCreate</span>(kCFAllocatorDefault,</div><div class=\"line\">                                                            kCFRunLoopAllActivities,</div><div class=\"line\">                                                            <span class=\"literal\">YES</span>,</div><div class=\"line\">                                                            <span class=\"number\">0</span>,</div><div class=\"line\">                                                            &amp;runLoopObserverCallBack,</div><div class=\"line\">                                                            &amp;context);</div><div class=\"line\">    <span class=\"built_in\">CFRunLoopAddObserver</span>(<span class=\"built_in\">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 创建信号</span></div><div class=\"line\">    semaphore = dispatch_semaphore_create(<span class=\"number\">0</span>);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 在子线程监控时长</span></div><div class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">YES</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"comment\">// 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)</span></div><div class=\"line\">            <span class=\"keyword\">long</span> st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, <span class=\"number\">50</span>*<span class=\"built_in\">NSEC_PER_MSEC</span>));</div><div class=\"line\">            <span class=\"keyword\">if</span> (st != <span class=\"number\">0</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (++timeoutCount &lt; <span class=\"number\">5</span>)</div><div class=\"line\">                        <span class=\"keyword\">continue</span>;</div><div class=\"line\">                    </div><div class=\"line\">                    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"好像有点儿卡哦\"</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            timeoutCount = <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"记录卡顿的函数调用\"><a href=\"#记录卡顿的函数调用\" class=\"headerlink\" title=\"记录卡顿的函数调用\"></a>记录卡顿的函数调用</h3><p><br /></p>\n<blockquote>\n<p>监控到了卡顿现场,当然下一步便是记录此时的函数调用信息,此处可以使用一个第三方Crash收集组件PLCrashReporter,它不仅可以收集Crash信息也可用于实时获取各线程的调用堆栈,使用示例如下:</p>\n</blockquote>\n<p><br /></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><div class=\"line\">PLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD</div><div class=\"line\">                                                                   symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];</div><div class=\"line\">PLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration:config];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSData</span> *data = [crashReporter generateLiveReport];</div><div class=\"line\">PLCrashReport *reporter = [[PLCrashReport alloc] initWithData:data error:<span class=\"literal\">NULL</span>];</div><div class=\"line\"><span class=\"built_in\">NSString</span> *report = [PLCrashReportTextFormatter stringValueForCrashReport:reporter</div><div class=\"line\">                                                          withTextFormat:PLCrashReportTextFormatiOS];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"------------\\n%@\\n------------\"</span>, report);</div></pre></td></tr></table></figure>\n<p>当检测到卡顿时,抓取堆栈信息,然后在客户端做一些过滤处理,便可以上报到服务器,通过收集一定量的卡顿数据后经过分析便能准确定位需要优化的逻辑,至此这个实时卡顿监控就大功告成了!</p>\n"},{"title":"iOS RunLoop","date":"2016-10-14T04:46:57.000Z","_content":"\n# RunLoop\n## `CFRunLoop` vs `NSRunLoop`\n`CFRunLoop` 是 `NSRunLoop` 在 `CoreFoundation` 中的底层形式，即 `NSRunLoop` 是 `CFRunLoop` 的封装。<br>\n\n`CFRunLoop` 有一个通用启动方法，`NSRunLoop` 通过指定该方法的 `timeout` 参数和 `stopAfterHandle` ，来实现\n```obj-c\n[[NSRunLoop currentRunLoop] run];\n```\n和\n```obj-c\n[[NSRunLoop currentRunLoop] runUntilDate:[NSDate date]];\n```\n\n## `source0` vs `source1`\n我们平时在 `NSThread` 层手动创建线程的时候，会手动启动一个 `NSRunLoop`。代码形如\n```obj-c\n[[NSRunLoop currentRunLoop] addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];\nwhile (running) {\n\t[[NSRunLoop currentRunLoop] run];\n}\n```\n在代码中向 `NSRunLoop` 添加的 `[NSMachPort port]` 即是一个端口，通常用于通过 `Mach` 实现进程间通信。在此添加是为了不让 `runloop` 一直处于循环之中，添加 `port` 可以使 `runloop` 在没有事件需要处理的时候进入等待状态。<br>\n`NSMachPort` 就属于一种 `source1` ，添加到 `runloop` 当中。其他进程可以通过其暴露的 `port` 向其通信，并且唤醒 `runloop` 开始处理事件。<br>\n比如：\n\n- 硬件方面\n  - 各种传感器传来的事件\n  - 用户点击屏幕的事件等\n\n- 底层事件\n  - 如网络请求等\n\n`source1` 被处理时会触发添加 `source` 时声明的回调函数。<br>\n比如用户触摸屏幕会由系统将 `source1` 标记为已准备，而 `app` 层面的 `UIEvent` 则是在该 `source1` 的回调函数中手动触发某 `source0`，然后唤醒 `runloop` 处理该 `source0`。因此，接收到 `UIEvent` 是从 `source0` 处被调用。\n\n## `CFRunLoop` 流程\n\n{% raw %}\n<textarea id=\"flowchart_code\" style=\"display: none;\">\nstart=>start: CFRunLoop\nend=>end: Exit\nop1=>operation: Get CurrentMode\nop2=>operation: doObserver: kCFRunLoopEntry\nop3=>operation: Entry: currentMode\nop4=>operation: doObserver: kCFRunLoopBeforeTimers\nop5=>operation: doObserver: kCFRunLoopBeforeSources\nop6=>operation: doBlocks: from dispatch (?)\nop7=>operation: doSource0: 调用被CFRunLoopSourceSignal(source)标记的source0\nop8=>operation: doBlocks\ncond1=>condition: source1 ready?\nop9=>operation: doObserver: kCFRunLoopBeforeWaiting\nop10=>operation: mach_msg(msg, MACH_RCV_MSG, port)\ncond2=>condition: WakeUp?\nop11=>operation: doObserver: kCFRunLoopAfterWaiting\nop12=>operation: handleMsg\nop13=>operation: doTimers/do dispatch到main_queue的block/doSource1\nop14=>operation: doBlocks\ncond3=>condition: ModeIsEmpty?\nop15=>operation: doObserver: kCFRunLoopExit\n\nstart->op1->op2->op3->op4->op5->op6->op7->op8\nop8->cond1\ncond1(yes)->op12\ncond1(no, left)->op9->op10\nop10->cond2\ncond2(yes)->op11\nop11(right)->op12->op13->op14->cond3\ncond3(no, left)->op4\ncond3(yes, right)->op15->end\n</textarea>\n<div id=\"flowchart_canvas\"></div>\n{% endraw %}\n\n","source":"_posts/iOS-RunLoop.md","raw":"---\ntitle: iOS RunLoop\ndate: 2016-10-14 12:46:57\ntags:\n- iOS\n- Code\n---\n\n# RunLoop\n## `CFRunLoop` vs `NSRunLoop`\n`CFRunLoop` 是 `NSRunLoop` 在 `CoreFoundation` 中的底层形式，即 `NSRunLoop` 是 `CFRunLoop` 的封装。<br>\n\n`CFRunLoop` 有一个通用启动方法，`NSRunLoop` 通过指定该方法的 `timeout` 参数和 `stopAfterHandle` ，来实现\n```obj-c\n[[NSRunLoop currentRunLoop] run];\n```\n和\n```obj-c\n[[NSRunLoop currentRunLoop] runUntilDate:[NSDate date]];\n```\n\n## `source0` vs `source1`\n我们平时在 `NSThread` 层手动创建线程的时候，会手动启动一个 `NSRunLoop`。代码形如\n```obj-c\n[[NSRunLoop currentRunLoop] addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];\nwhile (running) {\n\t[[NSRunLoop currentRunLoop] run];\n}\n```\n在代码中向 `NSRunLoop` 添加的 `[NSMachPort port]` 即是一个端口，通常用于通过 `Mach` 实现进程间通信。在此添加是为了不让 `runloop` 一直处于循环之中，添加 `port` 可以使 `runloop` 在没有事件需要处理的时候进入等待状态。<br>\n`NSMachPort` 就属于一种 `source1` ，添加到 `runloop` 当中。其他进程可以通过其暴露的 `port` 向其通信，并且唤醒 `runloop` 开始处理事件。<br>\n比如：\n\n- 硬件方面\n  - 各种传感器传来的事件\n  - 用户点击屏幕的事件等\n\n- 底层事件\n  - 如网络请求等\n\n`source1` 被处理时会触发添加 `source` 时声明的回调函数。<br>\n比如用户触摸屏幕会由系统将 `source1` 标记为已准备，而 `app` 层面的 `UIEvent` 则是在该 `source1` 的回调函数中手动触发某 `source0`，然后唤醒 `runloop` 处理该 `source0`。因此，接收到 `UIEvent` 是从 `source0` 处被调用。\n\n## `CFRunLoop` 流程\n\n{% raw %}\n<textarea id=\"flowchart_code\" style=\"display: none;\">\nstart=>start: CFRunLoop\nend=>end: Exit\nop1=>operation: Get CurrentMode\nop2=>operation: doObserver: kCFRunLoopEntry\nop3=>operation: Entry: currentMode\nop4=>operation: doObserver: kCFRunLoopBeforeTimers\nop5=>operation: doObserver: kCFRunLoopBeforeSources\nop6=>operation: doBlocks: from dispatch (?)\nop7=>operation: doSource0: 调用被CFRunLoopSourceSignal(source)标记的source0\nop8=>operation: doBlocks\ncond1=>condition: source1 ready?\nop9=>operation: doObserver: kCFRunLoopBeforeWaiting\nop10=>operation: mach_msg(msg, MACH_RCV_MSG, port)\ncond2=>condition: WakeUp?\nop11=>operation: doObserver: kCFRunLoopAfterWaiting\nop12=>operation: handleMsg\nop13=>operation: doTimers/do dispatch到main_queue的block/doSource1\nop14=>operation: doBlocks\ncond3=>condition: ModeIsEmpty?\nop15=>operation: doObserver: kCFRunLoopExit\n\nstart->op1->op2->op3->op4->op5->op6->op7->op8\nop8->cond1\ncond1(yes)->op12\ncond1(no, left)->op9->op10\nop10->cond2\ncond2(yes)->op11\nop11(right)->op12->op13->op14->cond3\ncond3(no, left)->op4\ncond3(yes, right)->op15->end\n</textarea>\n<div id=\"flowchart_canvas\"></div>\n{% endraw %}\n\n","slug":"iOS-RunLoop","published":1,"updated":"2016-10-14T10:26:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudswu7b0006de1ay5qw3cwm","content":"<h1 id=\"RunLoop\"><a href=\"#RunLoop\" class=\"headerlink\" title=\"RunLoop\"></a>RunLoop</h1><h2 id=\"CFRunLoop-vs-NSRunLoop\"><a href=\"#CFRunLoop-vs-NSRunLoop\" class=\"headerlink\" title=\"CFRunLoop vs NSRunLoop\"></a><code>CFRunLoop</code> vs <code>NSRunLoop</code></h2><p><code>CFRunLoop</code> 是 <code>NSRunLoop</code> 在 <code>CoreFoundation</code> 中的底层形式，即 <code>NSRunLoop</code> 是 <code>CFRunLoop</code> 的封装。<br></p>\n<p><code>CFRunLoop</code> 有一个通用启动方法，<code>NSRunLoop</code> 通过指定该方法的 <code>timeout</code> 参数和 <code>stopAfterHandle</code> ，来实现<br><figure class=\"highlight obj-c\"><table><tr><td class=\"code\"><pre><div class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] run];</div></pre></td></tr></table></figure></p>\n<p>和<br><figure class=\"highlight obj-c\"><table><tr><td class=\"code\"><pre><div class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] runUntilDate:[<span class=\"built_in\">NSDate</span> date]];</div></pre></td></tr></table></figure></p>\n<h2 id=\"source0-vs-source1\"><a href=\"#source0-vs-source1\" class=\"headerlink\" title=\"source0 vs source1\"></a><code>source0</code> vs <code>source1</code></h2><p>我们平时在 <code>NSThread</code> 层手动创建线程的时候，会手动启动一个 <code>NSRunLoop</code>。代码形如<br><figure class=\"highlight obj-c\"><table><tr><td class=\"code\"><pre><div class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addPort:[<span class=\"built_in\">NSMachPort</span> port] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</div><div class=\"line\"><span class=\"keyword\">while</span> (running) &#123;</div><div class=\"line\">\t[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] run];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在代码中向 <code>NSRunLoop</code> 添加的 <code>[NSMachPort port]</code> 即是一个端口，通常用于通过 <code>Mach</code> 实现进程间通信。在此添加是为了不让 <code>runloop</code> 一直处于循环之中，添加 <code>port</code> 可以使 <code>runloop</code> 在没有事件需要处理的时候进入等待状态。<br><br><code>NSMachPort</code> 就属于一种 <code>source1</code> ，添加到 <code>runloop</code> 当中。其他进程可以通过其暴露的 <code>port</code> 向其通信，并且唤醒 <code>runloop</code> 开始处理事件。<br><br>比如：</p>\n<ul>\n<li><p>硬件方面</p>\n<ul>\n<li>各种传感器传来的事件</li>\n<li>用户点击屏幕的事件等</li>\n</ul>\n</li>\n<li><p>底层事件</p>\n<ul>\n<li>如网络请求等</li>\n</ul>\n</li>\n</ul>\n<p><code>source1</code> 被处理时会触发添加 <code>source</code> 时声明的回调函数。<br><br>比如用户触摸屏幕会由系统将 <code>source1</code> 标记为已准备，而 <code>app</code> 层面的 <code>UIEvent</code> 则是在该 <code>source1</code> 的回调函数中手动触发某 <code>source0</code>，然后唤醒 <code>runloop</code> 处理该 <code>source0</code>。因此，接收到 <code>UIEvent</code> 是从 <code>source0</code> 处被调用。</p>\n<h2 id=\"CFRunLoop-流程\"><a href=\"#CFRunLoop-流程\" class=\"headerlink\" title=\"CFRunLoop 流程\"></a><code>CFRunLoop</code> 流程</h2>\n<textarea id=\"flowchart_code\" style=\"display: none;\">\nstart=>start: CFRunLoop\nend=>end: Exit\nop1=>operation: Get CurrentMode\nop2=>operation: doObserver: kCFRunLoopEntry\nop3=>operation: Entry: currentMode\nop4=>operation: doObserver: kCFRunLoopBeforeTimers\nop5=>operation: doObserver: kCFRunLoopBeforeSources\nop6=>operation: doBlocks: from dispatch (?)\nop7=>operation: doSource0: 调用被CFRunLoopSourceSignal(source)标记的source0\nop8=>operation: doBlocks\ncond1=>condition: source1 ready?\nop9=>operation: doObserver: kCFRunLoopBeforeWaiting\nop10=>operation: mach_msg(msg, MACH_RCV_MSG, port)\ncond2=>condition: WakeUp?\nop11=>operation: doObserver: kCFRunLoopAfterWaiting\nop12=>operation: handleMsg\nop13=>operation: doTimers/do dispatch到main_queue的block/doSource1\nop14=>operation: doBlocks\ncond3=>condition: ModeIsEmpty?\nop15=>operation: doObserver: kCFRunLoopExit\n\nstart->op1->op2->op3->op4->op5->op6->op7->op8\nop8->cond1\ncond1(yes)->op12\ncond1(no, left)->op9->op10\nop10->cond2\ncond2(yes)->op11\nop11(right)->op12->op13->op14->cond3\ncond3(no, left)->op4\ncond3(yes, right)->op15->end\n</textarea>\n<div id=\"flowchart_canvas\"></div>\n\n","excerpt":"","more":"<h1 id=\"RunLoop\"><a href=\"#RunLoop\" class=\"headerlink\" title=\"RunLoop\"></a>RunLoop</h1><h2 id=\"CFRunLoop-vs-NSRunLoop\"><a href=\"#CFRunLoop-vs-NSRunLoop\" class=\"headerlink\" title=\"CFRunLoop vs NSRunLoop\"></a><code>CFRunLoop</code> vs <code>NSRunLoop</code></h2><p><code>CFRunLoop</code> 是 <code>NSRunLoop</code> 在 <code>CoreFoundation</code> 中的底层形式，即 <code>NSRunLoop</code> 是 <code>CFRunLoop</code> 的封装。<br></p>\n<p><code>CFRunLoop</code> 有一个通用启动方法，<code>NSRunLoop</code> 通过指定该方法的 <code>timeout</code> 参数和 <code>stopAfterHandle</code> ，来实现<br><figure class=\"highlight obj-c\"><table><tr><td class=\"code\"><pre><div class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] run];</div></pre></td></tr></table></figure></p>\n<p>和<br><figure class=\"highlight obj-c\"><table><tr><td class=\"code\"><pre><div class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] runUntilDate:[<span class=\"built_in\">NSDate</span> date]];</div></pre></td></tr></table></figure></p>\n<h2 id=\"source0-vs-source1\"><a href=\"#source0-vs-source1\" class=\"headerlink\" title=\"source0 vs source1\"></a><code>source0</code> vs <code>source1</code></h2><p>我们平时在 <code>NSThread</code> 层手动创建线程的时候，会手动启动一个 <code>NSRunLoop</code>。代码形如<br><figure class=\"highlight obj-c\"><table><tr><td class=\"code\"><pre><div class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addPort:[<span class=\"built_in\">NSMachPort</span> port] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</div><div class=\"line\"><span class=\"keyword\">while</span> (running) &#123;</div><div class=\"line\">\t[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] run];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在代码中向 <code>NSRunLoop</code> 添加的 <code>[NSMachPort port]</code> 即是一个端口，通常用于通过 <code>Mach</code> 实现进程间通信。在此添加是为了不让 <code>runloop</code> 一直处于循环之中，添加 <code>port</code> 可以使 <code>runloop</code> 在没有事件需要处理的时候进入等待状态。<br><br><code>NSMachPort</code> 就属于一种 <code>source1</code> ，添加到 <code>runloop</code> 当中。其他进程可以通过其暴露的 <code>port</code> 向其通信，并且唤醒 <code>runloop</code> 开始处理事件。<br><br>比如：</p>\n<ul>\n<li><p>硬件方面</p>\n<ul>\n<li>各种传感器传来的事件</li>\n<li>用户点击屏幕的事件等</li>\n</ul>\n</li>\n<li><p>底层事件</p>\n<ul>\n<li>如网络请求等</li>\n</ul>\n</li>\n</ul>\n<p><code>source1</code> 被处理时会触发添加 <code>source</code> 时声明的回调函数。<br><br>比如用户触摸屏幕会由系统将 <code>source1</code> 标记为已准备，而 <code>app</code> 层面的 <code>UIEvent</code> 则是在该 <code>source1</code> 的回调函数中手动触发某 <code>source0</code>，然后唤醒 <code>runloop</code> 处理该 <code>source0</code>。因此，接收到 <code>UIEvent</code> 是从 <code>source0</code> 处被调用。</p>\n<h2 id=\"CFRunLoop-流程\"><a href=\"#CFRunLoop-流程\" class=\"headerlink\" title=\"CFRunLoop 流程\"></a><code>CFRunLoop</code> 流程</h2>\n<textarea id=\"flowchart_code\" style=\"display: none;\">\nstart=>start: CFRunLoop\nend=>end: Exit\nop1=>operation: Get CurrentMode\nop2=>operation: doObserver: kCFRunLoopEntry\nop3=>operation: Entry: currentMode\nop4=>operation: doObserver: kCFRunLoopBeforeTimers\nop5=>operation: doObserver: kCFRunLoopBeforeSources\nop6=>operation: doBlocks: from dispatch (?)\nop7=>operation: doSource0: 调用被CFRunLoopSourceSignal(source)标记的source0\nop8=>operation: doBlocks\ncond1=>condition: source1 ready?\nop9=>operation: doObserver: kCFRunLoopBeforeWaiting\nop10=>operation: mach_msg(msg, MACH_RCV_MSG, port)\ncond2=>condition: WakeUp?\nop11=>operation: doObserver: kCFRunLoopAfterWaiting\nop12=>operation: handleMsg\nop13=>operation: doTimers/do dispatch到main_queue的block/doSource1\nop14=>operation: doBlocks\ncond3=>condition: ModeIsEmpty?\nop15=>operation: doObserver: kCFRunLoopExit\n\nstart->op1->op2->op3->op4->op5->op6->op7->op8\nop8->cond1\ncond1(yes)->op12\ncond1(no, left)->op9->op10\nop10->cond2\ncond2(yes)->op11\nop11(right)->op12->op13->op14->cond3\ncond3(no, left)->op4\ncond3(yes, right)->op15->end\n</textarea>\n<div id=\"flowchart_canvas\"></div>\n\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ciudswu6y0001de1a01zsow5i","tag_id":"ciudswu750004de1a29hfijoz","_id":"ciudswu7g000ade1ant2goeh4"},{"post_id":"ciudswu6y0001de1a01zsow5i","tag_id":"ciudswu7d0007de1a1m9fimfi","_id":"ciudswu7g000bde1adswl0ww3"},{"post_id":"ciudswu6y0001de1a01zsow5i","tag_id":"ciudswu7e0008de1azs1zjn7x","_id":"ciudswu7g000dde1a8rguv0l7"},{"post_id":"ciudswu790005de1ar9yk0whc","tag_id":"ciudswu750004de1a29hfijoz","_id":"ciudswu7g000ede1axtyvmnpz"},{"post_id":"ciudswu7b0006de1ay5qw3cwm","tag_id":"ciudswu750004de1a29hfijoz","_id":"ciudswu7h000fde1aim45r3n8"},{"post_id":"ciudswu7b0006de1ay5qw3cwm","tag_id":"ciudswu7g000cde1amfv0rp2j","_id":"ciudswu7h000gde1a9hlsk66p"}],"Tag":[{"name":"iOS","_id":"ciudswu750004de1a29hfijoz"},{"name":"Framework","_id":"ciudswu7d0007de1a1m9fimfi"},{"name":"OpenSource","_id":"ciudswu7e0008de1azs1zjn7x"},{"name":"Code","_id":"ciudswu7g000cde1amfv0rp2j"}]}}